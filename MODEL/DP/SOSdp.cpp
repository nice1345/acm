
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const int N = 1<<20;
ll mod = (ll) 998244353;
int dp[N+5];

int main() {
    int n,ne;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&ne);
        dp[ne]++;
    }
    /**
     原理类似于一维一维的加,对于为什么不发生重复
     举例如下
     列如(111)的第一维的子集是(110),
              第二维的子集是(101),
     它们的公共子集有(100),
     但(100)是(110)第二维的子集,
     所以,(111)在第一维加上(110)的时候,
     (110)并没有加上第二维的子集(100),
     因此,(111)只加上了一次(100);
     当然它不止可以求前缀和,前缀积,前缀max,前缀min都可以
     * */
     /**求子集*/
    for(int w=0;w<20;w++){//w是维数
        for(int i=0;i<N;i++){
            if((i>>w)&1)dp[i]=(dp[i]+dp[i^(1<<w)])%mod;
        }
    }
    /**求超集*/
    for(int w=0;w<20;w++){//w是维数
        for(int i=0;i<N;i++){
            if(!((i>>w)&1))dp[i]=(dp[i]+dp[i^(1<<w)])%mod;
        }
    }
    /**
     实测发现
     w从0到19,i从0到1<<20-1,
     w从19到1,i从0到1<<20-1,
     w从0到19,i从1<<20-1到0,
     w从19到0,i从1<<20-1到0,
     四种遍历方式都是可以的,只要保证w(维数)在外层循环就行
     **/
    return 0;
}
